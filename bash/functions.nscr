# -*- Mode: sh -*-
#
# functions.nscr
#
# Personal aliases and functions

######################################################################
# General Aliases
######################################################################

alias mv='/bin/mv -i'

alias h='history'

# I used to hate less.  Weird.
alias more=less

alias names="awk '{print "'$NF'"}'"
alias lens="awk '{print length, \$0}'"

alias wd='basename `pwd`'
alias here='cd $cwd'

alias path='echo $PATH | tr ":" "\012"'

# ls aliases; some depend on default behavior of -l flag (whether it
# prints the group or not)

alias ls='/bin/ls -AF'
alias lt='/bin/ls -lt'
alias ltr='/bin/ls -ltr'
alias ll='/bin/ls -ln'
alias l='/bin/ls -lat | more'
alias s='/bin/ls' # for when I accidentally type ;s instead of ls
alias lsdirs="/bin/ls -l | grep ^d | awk '{print "'$NF'"}'"
alias files="/bin/ls -l | grep='^-' | awk '{print "'$NF'"}'"

alias lz='/bin/ls -1 | awk "{print length, \$0}" | sort -n | awk "{print \$2}"'
alias ds='/bin/ls -l | grep ^d'
alias subdirs='/bin/ls -ld */* | grep ^d'

# git aliases; need more work...
alias gup='git fetch --prune && git rebase origin/master master'
alias gtb='git branch --sort=committerdate'
alias cont='git `conflict-status` --continue'
alias abort='git `conflict-status` --abort'
alias skip='git `conflict-status` --skip'
alias glo='git log --oneline --reverse'
alias gloh='git log --oneline --reverse | head -20'
alias glot='git log --oneline --reverse -n 20'

alias cf="cd ${JV_ENV_HOME}"

alias wndw='echo -n -e "\033]0;Git Bash\a"'
alias cleen='/bin/rm -f `find . -name "*.pyc"`'
alias nw='export DISPLAY=""'

alias noserver='emacsclient -e "(server-force-delete)"'


export JVFILES=~/Documents/Logs/all-files.log
alias fff='find ~ -type f > ${JVFILES}'
function jvgrep
{
  egrep $* ${JVFILES}
}

function jvgrepx
{
  suf=$1
  patt='\.'${suf}'$'
  egrep ${patt} ${JVFILES}
}

function ff
{
  dir=`echo $1 | sed 's,/*$,,g'`
  shift
  find $dir -type f $* | sort
}

function filegrep
{
  sdir=$1
  flist=$2
  shift
  shift
  cd $sdir
  egrep $* `cat $flist`
}

function countlines
{
  sort | uniq -c | sort -n
}

function countg
{
  egrep -c $* | awk -F: '{printf("%s %s\n", $2, $1)}' | grep -v '^0'
}

function getsuf
{
  awk -F/ '{print $NF}' | awk -F. '{if (NF > 1) print $NF}'
}

function cntsuf
{
  getsuf | countlines
}

function cntisuf
{
  getsuf | tr '[A-Z]' '[a-z]' | countlines
}

function cntslash
{
  awk -F/ '{print NF " " $0}' | sort -n
}

function weirdsuf
{
  getsuf | grep -v '^[a-zA-Z0-9]*~*$' | grep -v ',v$' | sort | uniq | lens | sort -nr
}

function odiff
{
    diff $2 $1/$2
}

function jsonize
{
    cat $1 | python -mjson.tool
}

# upcd - go up (i.e., chdir) the directory hierarchy until finding the specified file
function upcd
{
    if [ -z "$1" ]
    then
        echo "Error: upcd must receive a filename to look for"
        return
    fi
    if [ -n "$2" ]
    then
        echo "Error: upcd takes only one argument, a filename to look for"
        return
    fi
    sfile=$1
    orig=${PWD}
    while [ ! -f ./${sfile} ]
    do
        if [ "/" = ${PWD} ]
        then
            echo "Could not locate ${sfile} in any parent directory of ${orig}"
            cd $orig
            break
        fi
        cd ..
    done
    # The unset is so that zsh doesn't "helpfully" change the prompt
    # as it does when we cd into a directory stored in a variable
    unset orig
    unset sfile
}

function gst
{
  sandbox=`git rev-parse --show-toplevel 2>/dev/null`
  if [ -n "${sandbox}" ]
  then
    git status | head -2
    git status -s | sort -k 2
  else
    /bin/ls -AF
  fi
}

# Get git status for each directory in the working directory
function sgst
{
    here=${PWD}
    for pkg in *
    do
        cd ${here}/${pkg}
        if [ -d ./.git/. ]
        then
            echo ${pkg}
            git status -s
        else
            echo "++ ${pkg} not a git repository"
        fi
    done
    cd ${here}
    unset here
}

function glm
{
  rev=HEAD
  if [ -n "$1" ]
  then
    rev=$1
    shift
  fi
  git log --oneline --reverse origin/master..${rev} $*
}

function ol
{
    nlines=10
    if [ -z "$1" ]
    then
        echo "Error: ol must receive a filename to show log"
        return
    fi
    if [ -n "$2" ]
    then
        nlines=$2
    fi
    if [ -n "$3" ]
    then
        echo "Error: ol takes at most two arguments"
        return
    fi
    gfile=$1
    git log --oneline ${gfile} | head -${nlines}
}

function writable
{
  chmod ug+rw $*
  chflags -R nouchange $*
}

function jsfiles
{
  find . -type f | egrep -v '\.git' | egrep -v '/test/' | egrep -v '/dist/'
}

function jsgrep
{
  find . -type f | egrep -v '\.git' | egrep -v '/test/' | egrep -v '/dist/' | xargs egrep $*
}
