#!/usr/bin/env python

from os import path, walk, rename
from collections import defaultdict
import re
import logging

logging.basicConfig(format='%(levelname)s: %(message)s', level=logging.INFO)

# Setting domove to False does not really work.  See comment in file_exists.
domove = True
new_is_low = True
verbose = False

mypath = "."
start_index = 2
separator = "~"
keyjoiner = "|"

class FileInfo:
    def __init__(self, prefix, extension, root, fname):
        self.prefix = prefix
        self.extension = extension
        self.root = root
        self.fname = fname
        self.path = path.join(root, fname)
        try:
            self.mtime = path.getmtime(self.path)
        except Exception as e:
            # TODO: this can happen if fpath is a dead symbolic link
            # There's probably a way to check that beforehand.
            # Use os.stat instead of getmtime
            self.mtime = 0

    def append_dir(self, fname):
        return path.join(self.root, fname)

    def make_versioned_file(self, fmt, offset):
        if (offset == 0) and (start_index < 2):
            return self.prefix + self.extension
        else:
            version = offset + start_index
            return self.prefix + separator + format(version, fmt) + self.extension



def padding_string(count):
    # This could be less hard-coded/pedantic, and we might even want to handle four digits
    if count < (10 - start_index):
        return '01'
    elif count < (100 - start_index):
        return '02'
    else:
        return '03'

def file_exists(pathname):
    if domove:
        does_exist = path.exists(pathname)
        # could do debug logging here
        return does_exist
    else:
        # TODO!!!  In order to do the "don't actually move, just tell me what
        # you would do" functionality, we'd need to maintain a data structure
        # to represent the file system we're creating; and then, this function
        # would consult that data structure.
        return False

def get_nonexistent_file(prefix, extension):
    index = 3
    name = prefix + separator + str(index) + extension
    while file_exists(name):
        index += 1
        name = prefix + separator + str(index) + extension
    return name

def timestamp_of(file_info):
    return file_info.mtime

def filename_to_key(fname):
    index_re = '[-~][0-9~]+$'
    junk_re = '[-~ .]+$'

    basename, extension = path.splitext(fname)
    prefix = re.sub(index_re, '', basename)
    prefix = re.sub(junk_re, '', prefix)
    key = prefix + keyjoiner + extension
    return key.lower(), prefix, extension

def map_by_basic_name(rootdir):
    filemap = defaultdict(list)
    for root, subfolders, subfiles in walk(rootdir):
        for fname in subfiles:
            key, prefix, extension = filename_to_key(fname)
            filemap[key].append(FileInfo(prefix, extension, root, fname))
    return filemap

def build_file_moves(filemap):
    fmoves = {}

    for key in filemap:
        index = 0
        filemap[key].sort(key=timestamp_of, reverse=new_is_low)
        fmt = padding_string(len(filemap[key]))
        for fileinfo in filemap[key]:
            destfile = fileinfo.make_versioned_file(fmt, index)
            dest = fileinfo.append_dir(destfile)

            src = fileinfo.path
            if dest.lower() != src.lower():
                if src not in fmoves:
                    fmoves[src] = [dest]
                else:
                    logging.info('error: already had move for {0}'.format(src))
                    # get rid of the old value, too; call things off!
                    del fmoves[src]
            elif verbose:
                logging.info('  - {0} stays as is'.format(src))
            index += 1
    return fmoves

def move_file(src, dst):
    if domove:
        logging.info("moving {0} to {1}".format(src, dst))
        rename(src, dst)
    else:
        logging.info("mv {0}\n      to {1}".format(src, dst))

def do_easy_moves(allmoves):
    sources = list(allmoves.keys())
    nmoves = len(sources)
    for src in sources:
        moves = allmoves[src]
        dest = moves[0]
        if file_exists(dest):
            logging.info('postponing: {0} -> {1}'.format(src, dest))
        else:
            move_file(src, dest)
            if (len(moves) == 1) :
                del allmoves[src]
            else:
                del allmoves[src][0]

    if verbose:
        logging.info('{0} out of {1} moves are trickier'.format(len(allmoves), nmoves))

def do_hard_moves_1(hardmoves):
    not_done = {}

    for src in hardmoves:
        dest = hardmoves[src][0]
        if dest.lower() == src.lower():
            logging.info("hard move: {0} already in place".format(dest))
        elif file_exists(dest):
            key, prefix, extension = filename_to_key(dest)
            temp = get_nonexistent_file(prefix, extension)
            move_file(src, temp)
            not_done[temp] = [dest]
        else:
            move_file(src, dest)
    return not_done

def do_hard_moves(hardmoves):
    to_do = hardmoves
    not_done = {}

    while True:
        not_done = do_hard_moves_1(to_do)
        if not_done:
            to_do = not_done
        else:
            break

def rename_files():
    mymap = map_by_basic_name(mypath)
    moves = build_file_moves(mymap)
    do_easy_moves(moves)
    do_hard_moves(moves)


rename_files()
